<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>God Mode: Hand Link</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* START OVERLAY */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
            z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; transition: opacity 0.5s ease;
        }
        #start-overlay h1 { font-weight: 800; letter-spacing: 5px; text-transform: uppercase; font-size: 40px; margin-bottom: 10px; color: #fff; }
        #start-btn { padding: 15px 40px; font-size: 14px; border-radius: 4px; background: white; border: none; color: black; cursor: pointer; font-weight: 800; text-transform: uppercase; letter-spacing: 1px; transition: transform 0.2s; }
        #start-btn:hover { transform: scale(1.05); }

        /* UI */
        #ui-container { position: absolute; top: 20px; left: 20px; z-index: 10; display: flex; flex-direction: column; gap: 10px; pointer-events: none; opacity: 0; transition: opacity 1s; }
        .panel { background: rgba(20, 20, 20, 0.8); backdrop-filter: blur(10px); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); width: 200px; pointer-events: auto; }
        
        /* BUTTONS */
        .mode-switch { display: flex; background: #000; padding: 4px; border-radius: 6px; margin-bottom: 10px; }
        .mode-btn { flex: 1; background: none; border: none; color: #666; padding: 8px; font-size: 11px; cursor: pointer; border-radius: 4px; font-weight: bold; }
        .mode-btn.active { background: #333; color: white; }

        .grid-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .action-btn { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; color: #aaa; cursor: pointer; font-size: 11px; text-align: center; }
        .action-btn.active { background: #fff; color: #000; font-weight: bold; }

        /* GUIDES */
        .guide { margin-top: 10px; font-size: 11px; color: #888; line-height: 1.6; }
        .key { color: white; font-weight: bold; }

        #status-bar { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 12px; pointer-events: none; opacity: 0; }
        #video-input { display: none; }
        #camera-preview { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; border-radius: 8px; opacity: 0; border: 1px solid #333; transform: scaleX(-1); }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h1>GOD MODE</h1>
        <p style="color:#666; font-size:12px; margin-bottom: 30px;">DIRECT NEURAL LINK</p>
        <button id="start-btn">INITIALIZE</button>
    </div>

    <div id="ui-container">
        <div class="panel">
            <div class="mode-switch">
                <button class="mode-btn active" onclick="setMode('particles')">PARTICLES</button>
                <button class="mode-btn" onclick="setMode('solid')">SOLID</button>
            </div>
            <div class="grid-buttons">
                <button onclick="setShape('zen')" class="action-btn active">ZEN</button>
                <button onclick="setShape('skull')" class="action-btn">SKULL</button>
                <button onclick="setShape('galaxy')" class="action-btn">GALAXY</button>
                <button onclick="setShape('cube')" class="action-btn">CUBE</button>
            </div>
            <div class="guide">
                <span class="key">✊ Fist (Hold):</span><br>
                - Rotates Model (Upside down)<br>
                - Pull Back = Zoom In<br>
                - Push Forward = Zoom Out<br><br>
                <span class="key">✋ Open Hand:</span><br>
                - Release to Freeze
            </div>
        </div>
    </div>

    <div id="status-bar">Waiting for Hand Input...</div>
    <video id="video-input"></video>
    <canvas id="camera-preview"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- CONFIG ---
        const CONFIG = {
            particleCount: 25000,
            lerpSpeed: 0.1, // Smoothness of movement
        };

        const STATE = {
            mode: 'particles',
            isFist: false,
            // Target transforms (where we want to be)
            targetRot: { x: 0, y: 0, z: 0 },
            targetScale: 1.0,
            // Current transforms (where we are)
            currentScale: 1.0
        };

        // --- THREE.JS ---
        let scene, camera, renderer;
        let particleSystem, solidMesh, container; // Container holds everything to rotate it easily
        let particleGeo, targetPositions;

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lights
            const al = new THREE.AmbientLight(0x404040);
            scene.add(al);
            const dl = new THREE.DirectionalLight(0xffffff, 1);
            dl.position.set(10, 10, 10);
            scene.add(dl);

            // CONTAINER (This is what we rotate/scale)
            container = new THREE.Group();
            scene.add(container);

            // 1. PARTICLES
            particleGeo = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.particleCount * 3);
            targetPositions = new Float32Array(CONFIG.particleCount * 3);
            const cols = new Float32Array(CONFIG.particleCount * 3);
            
            for(let i=0; i<CONFIG.particleCount*3; i++) {
                pos[i] = (Math.random()-0.5)*100;
                targetPositions[i] = pos[i];
                cols[i] = 1;
            }
            particleGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            particleGeo.setAttribute('color', new THREE.BufferAttribute(cols, 3));

            const pMat = new THREE.PointsMaterial({
                size: 0.2, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });
            particleSystem = new THREE.Points(particleGeo, pMat);
            container.add(particleSystem);

            // 2. SOLID OBJECT
            const sGeo = new THREE.IcosahedronGeometry(8, 1);
            const sMat = new THREE.MeshStandardMaterial({ 
                color: 0x00d2ff, roughness: 0.2, metalness: 0.8, wireframe: true 
            });
            solidMesh = new THREE.Mesh(sGeo, sMat);
            solidMesh.visible = false;
            container.add(solidMesh);

            setShape('zen');
            animate();
            initHands();
        }

        // --- SHAPES ---
        window.setShape = (name) => {
            const btns = document.querySelectorAll('.action-btn');
            btns.forEach(b => b.classList.remove('active'));
            // Just update particle targets
            let func;
            if (name === 'zen') func = (i) => {
                const p = i/CONFIG.particleCount;
                if(p<0.15) { const r=2.2,th=Math.random()*6.28,ph=Math.acos(2*Math.random()-1); return [r*Math.sin(ph)*Math.cos(th), r*Math.sin(ph)*Math.sin(th)+6, r*Math.cos(ph)]; }
                if(p<0.5) { const r=3.5,h=7*Math.random(),a=Math.random()*6.28; return [r*Math.cos(a)*0.7, h-2, r*Math.sin(a)*0.5]; }
                const s=Math.random()>0.5?1:-1, t=Math.random()*3.14; return [s*(3+t*2.5), -2-Math.sin(t)*2.5, Math.cos(t)*3];
            };
            else if (name === 'skull') func = () => { const r=8,t=Math.random()*6.28,p=Math.acos(2*Math.random()-1); let x=r*Math.sin(p)*Math.cos(t),y=r*Math.sin(p)*Math.sin(t),z=r*Math.cos(p); if(y<-3){x*=0.6;z*=0.6;} if(z>4&&y>0&&Math.abs(x)<3) z=2; return [x,y,z]; };
            else if (name === 'galaxy') func = (i) => { const a=(i%3)*2.09+i*0.001, d=Math.random()*20; return [Math.cos(a)*d, (Math.random()-0.5)*(20-d)*0.5, Math.sin(a)*d]; };
            else func = () => { const s=12; return [(Math.random()-0.5)*s, (Math.random()-0.5)*s, (Math.random()-0.5)*s]; }; // Cube/Chaos

            for(let i=0; i<CONFIG.particleCount; i++) {
                const [x,y,z] = func(i);
                targetPositions[i*3] = x; targetPositions[i*3+1] = y; targetPositions[i*3+2] = z;
            }
        };

        window.setMode = (m) => {
            STATE.mode = m;
            particleSystem.visible = (m === 'particles');
            solidMesh.visible = (m === 'solid');
            // Update UI styles
            const btns = document.querySelectorAll('.mode-btn');
            btns.forEach(b => b.classList.remove('active'));
            // Simple logic for tab highlight not strictly needed for functionality
        };

        // --- HAND TRACKING LOGIC ---
        function initHands() {
            const video = document.getElementById('video-input');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6});
            
            hands.onResults(results => {
                const ctx = document.getElementById('camera-preview').getContext('2d');
                ctx.clearRect(0,0,160,120);
                ctx.drawImage(results.image, 0,0,160,120);

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    
                    // 1. Detect Fist
                    // Check if fingertips (12, 16, 20) are close to wrist (0)
                    const wrist = lm[0];
                    const tip = lm[12]; // Middle finger tip
                    const distFist = Math.sqrt(Math.pow(tip.x-wrist.x, 2) + Math.pow(tip.y-wrist.y, 2));
                    const isFist = distFist < 0.25; // Adjusted threshold for better fist detection
                    
                    STATE.isFist = isFist;

                    if (isFist) {
                        document.getElementById('status-bar').innerText = "LINKED (FIST)";
                        document.getElementById('status-bar').style.color = "#00ff00";

                        // --- ROTATION MAPPING ---
                        // Use the vector from Wrist(0) to Index MCP(5) to determine orientation
                        const p0 = lm[0];
                        const p9 = lm[9]; // Middle finger knuckle

                        const dx = p9.x - p0.x;
                        const dy = p9.y - p0.y;
                        
                        // Z Rotation: Angle of the hand on screen (Upside down / Tilted)
                        // Invert angle because screen Y is flipped in 3D
                        const angleZ = Math.atan2(dy, dx); 
                        // Offset by 90 degrees (PI/2) so upright hand = upright model
                        STATE.targetRot.z = -(angleZ + Math.PI/2); 

                        // X/Y Rotation: Based on Hand Position on Screen
                        // Center is 0.5, 0.5. 
                        // Map X (0-1) to Y Rotation (-PI to PI)
                        STATE.targetRot.y = (lm[9].x - 0.5) * 4; 
                        // Map Y (0-1) to X Rotation
                        STATE.targetRot.x = (lm[9].y - 0.5) * 4;


                        // --- ZOOM MAPPING (The Inverse Logic) ---
                        // Measure hand size (Wrist 0 to Index MCP 5) to guess depth
                        // Close to camera = Large Distance = Large Hand Size
                        // Far from camera = Small Distance = Small Hand Size
                        const p5 = lm[5];
                        const handSize = Math.sqrt(Math.pow(p5.x - p0.x, 2) + Math.pow(p5.y - p0.y, 2));
                        
                        // User Request: "Pull hands back (small size) = Zooms In (Scale Up)"
                        // User Request: "Put hand closer (big size) = Puts model farther (Scale Down)"
                        
                        // Base handSize is usually around 0.1 to 0.3
                        // Formula: Scale = Constant / handSize
                        const zoomFactor = 0.05 / Math.max(0.01, handSize); 
                        STATE.targetScale = Math.min(3.0, Math.max(0.2, zoomFactor));

                    } else {
                        document.getElementById('status-bar').innerText = "RELEASED (OPEN HAND)";
                        document.getElementById('status-bar').style.color = "#fff";
                    }
                }
            });

            const cameraUtils = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 640, height: 480
            });
            cameraUtils.start();
        }

        function animate() {
            requestAnimationFrame(animate);

            // Interpolate Container Transform (The Clutch)
            if (STATE.isFist) {
                // Smoothly move towards target
                container.rotation.x += (STATE.targetRot.x - container.rotation.x) * CONFIG.lerpSpeed;
                container.rotation.y += (STATE.targetRot.y - container.rotation.y) * CONFIG.lerpSpeed;
                container.rotation.z += (STATE.targetRot.z - container.rotation.z) * CONFIG.lerpSpeed;
                
                STATE.currentScale += (STATE.targetScale - STATE.currentScale) * CONFIG.lerpSpeed;
                container.scale.set(STATE.currentScale, STATE.currentScale, STATE.currentScale);
            }
            // If !isFist, we do nothing. The model stays exactly where it was.

            // Animate Particles internally (physics spring)
            if (STATE.mode === 'particles') {
                const pos = particleGeo.attributes.position.array;
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const ix = i*3;
                    pos[ix] += (targetPositions[ix] - pos[ix]) * 0.1;
                    pos[ix+1] += (targetPositions[ix+1] - pos[ix+1]) * 0.1;
                    pos[ix+2] += (targetPositions[ix+2] - pos[ix+2]) * 0.1;
                }
                particleGeo.attributes.position.needsUpdate = true;
            }

            // Animate Solid Mesh (Idle spin only if in solid mode)
            if (STATE.mode === 'solid') {
                solidMesh.rotation.z += 0.002; // Tiny internal spin
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            init();
            document.getElementById('start-overlay').style.opacity = 0;
            setTimeout(() => document.getElementById('start-overlay').remove(), 500);
            document.getElementById('ui-container').style.opacity = 1;
            document.getElementById('status-bar').style.opacity = 1;
            document.getElementById('camera-preview').style.opacity = 0.5;
        });
    </script>
</body>
</html>
