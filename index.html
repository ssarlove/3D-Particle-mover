<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Particle Engine</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* START SCREEN */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); backdrop-filter: blur(20px);
            z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; transition: opacity 0.5s ease;
        }
        #start-overlay h1 { font-weight: 300; letter-spacing: 6px; text-transform: uppercase; background: linear-gradient(90deg, #00d2ff, #3a7bd5); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-size: 32px; }
        #start-btn { padding: 15px 50px; font-size: 14px; border-radius: 50px; background: white; border: none; cursor: pointer; font-weight: 700; text-transform: uppercase; margin-top: 30px; letter-spacing: 2px; transition: transform 0.2s; }
        #start-btn:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(0, 210, 255, 0.4); }

        /* UI PANELS */
        #ui-container { position: absolute; top: 20px; left: 20px; z-index: 10; display: flex; flex-direction: column; gap: 15px; pointer-events: none; opacity: 0; transition: opacity 1s; }
        .panel { background: rgba(15, 15, 15, 0.85); backdrop-filter: blur(12px); padding: 16px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.08); color: white; width: 220px; pointer-events: auto; }
        h2 { margin: 0 0 12px 0; font-size: 10px; text-transform: uppercase; letter-spacing: 1.5px; color: #666; font-weight: 700; }

        /* BUTTONS & UPLOAD */
        .grid-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
        .shape-btn { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; color: #aaa; cursor: pointer; font-size: 11px; transition: 0.2s; }
        .shape-btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .shape-btn.active { background: #00d2ff; color: #000; font-weight: bold; border-color: #00d2ff; }

        /* CUSTOM FILE UPLOAD */
        .upload-btn-wrapper { position: relative; overflow: hidden; display: inline-block; width: 100%; margin-top: 5px;}
        .btn-upload { border: 1px dashed rgba(255,255,255,0.3); color: white; background-color: rgba(255,255,255,0.05); padding: 12px; border-radius: 8px; font-size: 12px; font-weight: bold; width: 100%; cursor: pointer; text-align: center; transition: 0.3s; }
        .btn-upload:hover { background: rgba(255,255,255,0.1); border-color: white; }
        .upload-btn-wrapper input[type=file] { font-size: 100px; position: absolute; left: 0; top: 0; opacity: 0; cursor: pointer; width: 100%; height: 100%; }

        /* STATUS & PREVIEW */
        #status-bar { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.5); font-size: 13px; text-align: center; opacity: 0; pointer-events: none; letter-spacing: 1px; width: 100%; }
        #camera-preview { position: absolute; bottom: 20px; right: 20px; width: 140px; height: 105px; border-radius: 10px; opacity: 0; border: 1px solid rgba(255,255,255,0.1); transform: scaleX(-1); transition: opacity 1s; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        #video-input { display: none; }
        
        /* FLASH EFFECT */
        #flash { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; z-index: 999; transition: opacity 0.1s; }
    </style>
</head>
<body>

    <div id="flash"></div>

    <!-- START SCREEN -->
    <div id="start-overlay">
        <h1>Particle Engine</h1>
        <p style="color:#888; text-align:center; font-size: 13px; max-width: 300px; line-height: 1.6; margin-bottom: 20px;">
            Camera used for Hand Tracking.<br>
            Microphone used for Sound Control.
        </p>
        <button id="start-btn">Initialize System</button>
    </div>

    <!-- UI -->
    <div id="ui-container">
        
        <div class="panel">
            <h2>Image to Particles</h2>
            <div class="upload-btn-wrapper">
                <button class="btn-upload">üìÇ Upload Image</button>
                <input type="file" id="imageUpload" accept="image/*" />
            </div>
        </div>

        <div class="panel">
            <h2>Templates</h2>
            <div class="grid-buttons">
                <button onclick="setShape('zen')" class="shape-btn active" id="btn-zen">üßò Zen</button>
                <button onclick="setShape('heart')" class="shape-btn" id="btn-heart">‚ù§Ô∏è Heart</button>
                <button onclick="setShape('saturn')" class="shape-btn" id="btn-saturn">ü™ê Saturn</button>
                <button onclick="setShape('dna')" class="shape-btn" id="btn-dna">üß¨ DNA</button>
                <button onclick="setShape('sphere')" class="shape-btn" id="btn-sphere">‚ö™ Sphere</button>
                <button onclick="setShape('cube')" class="shape-btn" id="btn-cube">üßä Cube</button>
            </div>
        </div>

        <div class="panel">
            <h2>Controls</h2>
            <div style="font-size: 11px; line-height: 1.8; color:#bbb;">
                ‚úã <b>Move Hand:</b> Rotates Model<br>
                ‚ÜîÔ∏è <b>Hands Apart:</b> Zoom / Scale<br>
                üëè <b>Clap / Snap:</b> Change Shape<br>
            </div>
        </div>
    </div>

    <div id="status-bar">Waiting for inputs...</div>
    <video id="video-input"></video>
    <canvas id="camera-preview"></canvas>

    <!-- LIBRARIES -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- CONFIG ---
        const CONFIG = {
            particleCount: 25000,
            baseSize: 0.15,
            soundThreshold: 40 // Sensitivity of sound trigger
        };

        const STATE = {
            currentShape: 'zen',
            isCustomImage: false,
            handDistance: 0.2,
            targetRotation: { x: 0, y: 0 },
            lastSoundTime: 0,
            activeColor: new THREE.Color(0x00d2ff),
            originalImageColors: null // To store image colors
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 28;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- PARTICLES ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const targetPositions = new Float32Array(CONFIG.particleCount * 3);
        const colors = new Float32Array(CONFIG.particleCount * 3);
        const targetColors = new Float32Array(CONFIG.particleCount * 3);

        // Init positions and colors
        const baseColor = new THREE.Color(0x00d2ff);
        for (let i = 0; i < CONFIG.particleCount; i++) {
            positions[i*3] = (Math.random()-0.5)*100;
            positions[i*3+1] = (Math.random()-0.5)*100;
            positions[i*3+2] = (Math.random()-0.5)*100;
            targetPositions[i*3] = positions[i*3];
            
            colors[i*3] = baseColor.r;
            colors[i*3+1] = baseColor.g;
            colors[i*3+2] = baseColor.b;
            targetColors[i*3] = baseColor.r;
            targetColors[i*3+1] = baseColor.g;
            targetColors[i*3+2] = baseColor.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Texture
        const getSprite = () => {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.2,'rgba(255,255,255,0.8)');
            g.addColorStop(0.5,'rgba(255,255,255,0.2)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,32,32);
            return new THREE.Texture(c);
        };
        const matTexture = getSprite();
        matTexture.needsUpdate = true;

        const material = new THREE.PointsMaterial({
            size: CONFIG.baseSize,
            map: matTexture,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            vertexColors: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- MATH SHAPES ---
        const shapes = {
            zen: (i) => {
                const p = i / CONFIG.particleCount;
                let x,y,z;
                if (p < 0.15) { // Head
                    const r = 2.2; const theta = Math.random()*Math.PI*2; const phi = Math.acos(2*Math.random()-1);
                    x = r*Math.sin(phi)*Math.cos(theta); y = r*Math.sin(phi)*Math.sin(theta)+6.5; z = r*Math.cos(phi);
                } else if (p < 0.5) { // Body
                    const r = 3.5; const h = 7*Math.random(); const ang = Math.random()*Math.PI*2;
                    x = r*Math.cos(ang)*0.7; y = h-2; z = r*Math.sin(ang)*0.5;
                } else { // Legs
                    const side = Math.random()>0.5?1:-1; const t = Math.random()*Math.PI;
                    x = side*(3+t*2.5); y = -2-Math.sin(t)*2.5; z = Math.cos(t)*3;
                }
                return {x,y,z};
            },
            heart: (i) => {
                const t = (i/CONFIG.particleCount)*Math.PI*2;
                const x = 16*Math.pow(Math.sin(t),3);
                const y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
                const z = (Math.random()-0.5)*6;
                return {x:x*0.9, y:y*0.9, z};
            },
            dna: (i) => {
                const helix = i/80; const r=5; const s = i%2===0?1:-1;
                return { x:Math.cos(helix)*r+(Math.random()-0.5), y:(i/CONFIG.particleCount)*40-20, z:Math.sin(helix)*r*s };
            },
            saturn: (i) => {
                if (i<CONFIG.particleCount*0.6) {
                    const r=7; const phi=Math.acos(2*Math.random()-1); const th=Math.random()*Math.PI*2;
                    return {x:r*Math.sin(phi)*Math.cos(th), y:r*Math.sin(phi)*Math.sin(th), z:r*Math.cos(phi)};
                }
                const a=Math.random()*Math.PI*2; const d=10+Math.random()*8;
                return {x:Math.cos(a)*d, y:(Math.random()-0.5)*0.5, z:Math.sin(a)*d};
            },
            sphere: (i) => {
                const r=12; const phi=Math.acos(2*Math.random()-1); const th=Math.random()*Math.PI*2;
                return {x:r*Math.sin(phi)*Math.cos(th), y:r*Math.sin(phi)*Math.sin(th), z:r*Math.cos(phi)};
            },
            cube: (i) => {
                const s = 16;
                return {x:(Math.random()-0.5)*s, y:(Math.random()-0.5)*s, z:(Math.random()-0.5)*s};
            }
        };

        function updateShape() {
            if (STATE.isCustomImage) return; // Do not overwrite image positions
            const func = shapes[STATE.currentShape];
            
            // Set Color based on shape
            let cHex = 0xffffff;
            if(STATE.currentShape === 'zen') cHex = 0xffd700;
            if(STATE.currentShape === 'heart') cHex = 0xff3366;
            if(STATE.currentShape === 'dna') cHex = 0x00ff88;
            if(STATE.currentShape === 'saturn') cHex = 0xffaa00;
            if(STATE.currentShape === 'sphere') cHex = 0x00d2ff;
            if(STATE.currentShape === 'cube') cHex = 0xbd00ff;
            
            const col = new THREE.Color(cHex);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const pos = func(i);
                targetPositions[i*3] = pos.x;
                targetPositions[i*3+1] = pos.y;
                targetPositions[i*3+2] = pos.z;

                targetColors[i*3] = col.r;
                targetColors[i*3+1] = col.g;
                targetColors[i*3+2] = col.b;
            }
        }

        window.setShape = (name) => {
            STATE.isCustomImage = false;
            STATE.currentShape = name;
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('btn-'+name);
            if(btn) btn.classList.add('active');
            updateShape();
        };

        function cycleShape() {
            // Flash screen
            const flash = document.getElementById('flash');
            flash.style.opacity = 0.5;
            setTimeout(() => flash.style.opacity = 0, 100);

            const keys = Object.keys(shapes);
            let idx = keys.indexOf(STATE.currentShape);
            idx = (idx + 1) % keys.length;
            setShape(keys[idx]);
        }

        // --- IMAGE UPLOAD LOGIC ---
        const imageUpload = document.getElementById('imageUpload');
        imageUpload.addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => processImageParticles(img);
                    img.src = event.target.result;
                };
                reader.readAsDataURL(e.target.files[0]);
            }
        });

        function processImageParticles(img) {
            STATE.isCustomImage = true;
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Resize image to keep particle density meaningful
            const maxSize = 150; 
            let width = img.width;
            let height = img.height;
            if (width > height) {
                if (width > maxSize) { height *= maxSize / width; width = maxSize; }
            } else {
                if (height > maxSize) { width *= maxSize / height; height = maxSize; }
            }
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);

            const data = ctx.getImageData(0, 0, width, height).data;
            const validPixels = [];

            // Extract colored pixels
            for(let y=0; y<height; y++) {
                for(let x=0; x<width; x++) {
                    const idx = (y*width + x) * 4;
                    const r = data[idx];
                    const g = data[idx+1];
                    const b = data[idx+2];
                    const a = data[idx+3];
                    if (a > 128) {
                        validPixels.push({
                            x: (x - width/2) * 0.3, // Scale down
                            y: -(y - height/2) * 0.3, // Flip Y
                            color: { r: r/255, g: g/255, b: b/255 }
                        });
                    }
                }
            }

            // Shuffle pixels to randomize distribution among particle array
            validPixels.sort(() => Math.random() - 0.5);

            // Assign to particles
            for(let i=0; i<CONFIG.particleCount; i++) {
                if (i < validPixels.length) {
                    const p = validPixels[i];
                    targetPositions[i*3] = p.x;
                    targetPositions[i*3+1] = p.y;
                    targetPositions[i*3+2] = (Math.random()-0.5) * 2; // Slight 3D depth
                    
                    targetColors[i*3] = p.color.r;
                    targetColors[i*3+1] = p.color.g;
                    targetColors[i*3+2] = p.color.b;
                } else {
                    // Hide unused particles
                    targetPositions[i*3] = 0;
                    targetPositions[i*3+1] = 0;
                    targetPositions[i*3+2] = 5000; // Far away
                }
            }
        }

        // --- AUDIO (SOUND CHANGE) ---
        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                const dataArray = new Uint8Array(analyser.frequencyBinCount);

                function analyze() {
                    analyser.getByteFrequencyData(dataArray);
                    // Calculate average volume
                    let values = 0;
                    for(let i=0; i<dataArray.length; i++) values += dataArray[i];
                    const average = values / dataArray.length;

                    const now = Date.now();
                    // Threshold check + Cooldown (800ms)
                    if (average > CONFIG.soundThreshold && now > STATE.lastSoundTime + 800) {
                        STATE.lastSoundTime = now;
                        cycleShape();
                    }
                    requestAnimationFrame(analyze);
                }
                analyze();
            } catch (e) { console.error("Mic denied"); }
        }

        // --- HAND TRACKING (MOVEMENT) ---
        const videoElement = document.getElementById('video-input');
        const canvasCtx = document.getElementById('camera-preview').getContext('2d');
        const statusBar = document.getElementById('status-bar');

        function onResults(results) {
            canvasCtx.clearRect(0, 0, 140, 105);
            canvasCtx.drawImage(results.image, 0, 0, 140, 105);
            
            const landmarks = results.multiHandLandmarks;

            if (landmarks && landmarks.length > 0) {
                statusBar.innerText = "Hands Active";
                
                // 1. Movement / Rotation (Based on average hand position)
                // Get Center of all visible hands
                let avgX = 0, avgY = 0;
                let count = 0;
                landmarks.forEach(hand => {
                    const wrist = hand[9]; // Middle finger knuckle is stable
                    avgX += wrist.x;
                    avgY += wrist.y;
                    count++;
                });
                avgX /= count;
                avgY /= count;

                // Map 0..1 to -1..1
                // Hand moving Left (high X in mirrored video) -> Rotate Left
                // We use Lerp in animate loop, just set target here
                STATE.targetRotation.y = (avgX - 0.5) * 3; // Horizontal movement
                STATE.targetRotation.x = (avgY - 0.5) * 2; // Vertical movement

                // 2. Zoom / Scale (Distance between hands)
                if (landmarks.length === 2) {
                    const h1 = landmarks[0][9];
                    const h2 = landmarks[1][9];
                    const dist = Math.sqrt(Math.pow(h1.x-h2.x, 2) + Math.pow(h1.y-h2.y, 2));
                    STATE.handDistance += (dist - STATE.handDistance) * 0.1; // Smooth
                }
            } else {
                statusBar.innerText = "Waiting for hands...";
                // Gently reset rotation if hands lost
                STATE.targetRotation.x = 0;
                STATE.targetRotation.y = 0;
                STATE.handDistance += (0.2 - STATE.handDistance) * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        hands.onResults(onResults);

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const positionsArray = geometry.attributes.position.array;
            const colorsArray = geometry.attributes.color.array;

            // Smoothly move object based on hands
            particles.rotation.x += (STATE.targetRotation.x - particles.rotation.x) * 0.1;
            particles.rotation.y += (-STATE.targetRotation.y - particles.rotation.y) * 0.1; // Invert X for mirror feel

            // Scale logic
            const scale = 0.5 + (STATE.handDistance * 4.0);
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const ix = i * 3;
                
                // Position Lerp
                let tx = targetPositions[ix] * scale;
                let ty = targetPositions[ix+1] * scale;
                let tz = targetPositions[ix+2] * scale;
                
                positionsArray[ix] += (tx - positionsArray[ix]) * 0.12;
                positionsArray[ix+1] += (ty - positionsArray[ix+1]) * 0.12;
                positionsArray[ix+2] += (tz - positionsArray[ix+2]) * 0.12;

                // Color Lerp
                colorsArray[ix] += (targetColors[ix] - colorsArray[ix]) * 0.05;
                colorsArray[ix+1] += (targetColors[ix+1] - colorsArray[ix+1]) * 0.05;
                colorsArray[ix+2] += (targetColors[ix+2] - colorsArray[ix+2]) * 0.05;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- INITIALIZATION ---
        const startBtn = document.getElementById('start-btn');
        startBtn.addEventListener('click', async () => {
            startBtn.innerText = "Loading...";
            
            await initAudio(); // Start Mic

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            
            cameraUtils.start().then(() => {
                document.getElementById('start-overlay').style.opacity = 0;
                setTimeout(()=>document.getElementById('start-overlay').remove(), 500);
                document.getElementById('ui-container').style.opacity = 1;
                document.getElementById('status-bar').style.opacity = 1;
                document.getElementById('camera-preview').style.opacity = 0.6;
                setShape('zen');
                animate();
            });
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
